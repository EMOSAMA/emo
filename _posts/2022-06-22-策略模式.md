---
layout:     post
title:      Head First设计模式学习笔记一
subtitle:   策略模式
date:       2022-06-22
author:     Emo
header-img: img/unimelb-bd.png
catalog: true
tags:
- 设计模式
---

> 设计模式
> [练习实例仓库](https://github.com/EMOSAMA/DesignPatternTry)
> [EMO's Blog](https://emosama.github.io/)

**鸭子应用实例:** 滥用继承影响代码弹性
# **策略模式中的OO**
**OO基础：**

1. 抽象
1. 封装
1. 多态
1. 继承

**OO原则：**

1. 将“变化”与“不变化”的·代码分离 (封装变化)
1. 针对接口编程，而不是针对实现编程
1. 多用组合，少用继承

**OO模式：**

**策略模式**定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
# **具体解决方法**
将“变化”的部分从superclass中分离出来，在这里是FlyBehavior和QuackBehavior两部分。分离出来后用interface的方式去编程，将两个行为设计成接口类，然后再根据不同的行为种类去实现该接口的子类。这样我们既保有了继承带来的好处，有避免了继承带来的包袱。同时我们在构建鸭子子类的时候，我们可以看到FlyBehavior和QuackBehavior不再是从superclass中继承的具体实现，而是通过组合方式将其与外部的接口类绑定，再在初始化时指定该接口具体的实现。

<img src="{{site.url}}/img/2022-06-22-策略模式/p22.png">

Duck作为superclass与FlyBehavior以及QuackBehavior组合，而这两个行为分别封装为接口类，并在不同的行为子类中得到具体实现，这便是所谓的针对接口编程。不同的鸭子子类通过将FlyBehavior和QuackBehavior初始化成不同的行为接口的具体实现来绑定具体行为模式。
# **总结**
将superclass中设计“变化”的代码/方法分离出来，并用接口的形式单独构建类。最后这些“变化”的代码将以组合的方式而非继承的方式存在于superclass中。这个时候“变化”的代码的动态更新修改将变得非常灵活且易于维护。在这个例子中，鸭子的行为被封装进了一组类中，我们可以轻易的扩充和改变，并且在运行时我们也可以改变行为。因此策略模式讲的就是拆分与封装，将需要动态“变化”的代码拆分出来，封装进平行的接口类里面，并以虚拟的方式组合进原本的类当中，这样我们就可以灵活的进行扩展和修改甚至在运行时修改接口类指定的具体实现。
